//Largely generated by Gemini AI
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>
#include <X11/extensions/XInput2.h>

#define EXIT_KEYCODE 74   // Typically F8
#define WINDOW_SIZE  200
#define BLUE_PIXEL   0x0000FF

Display *display;
Window root, win;
int xi_opcode;
Cursor blank_cursor;
int center_x, center_y;
int is_capturing = 0;


Cursor create_blank_cursor() {
    Pixmap blank;
    XColor dummy;
    char data[1] = {0};
    blank = XCreateBitmapFromData(display, root, data, 1, 1);
    Cursor cursor = XCreatePixmapCursor(display, blank, blank, &dummy, &dummy, 0, 0);
    XFreePixmap(display, blank);
    return cursor;
}

void set_always_on_top(Window w) {
    Atom state = XInternAtom(display, "_NET_WM_STATE", False);
    Atom above = XInternAtom(display, "_NET_WM_STATE_ABOVE", False);
    XEvent xev;
    memset(&xev, 0, sizeof(xev));
    xev.type = ClientMessage;
    xev.xclient.window = w;
    xev.xclient.message_type = state;
    xev.xclient.format = 32;
    xev.xclient.data.l[0] = 1; 
    xev.xclient.data.l[1] = above;
    XSendEvent(display, root, False, SubstructureRedirectMask | SubstructureNotifyMask, &xev);
}

int grab_input() {
    //We probably need blank cursor for successful capturing (in XWayland)
    int res = XGrabPointer(display, win, False, 
                           ButtonPressMask | ButtonReleaseMask | PointerMotionMask,
                           GrabModeAsync, GrabModeAsync, 
                           win, blank_cursor, CurrentTime);
    if (res != GrabSuccess) return 0;

    XGrabKeyboard(display, win, False, GrabModeAsync, GrabModeAsync, CurrentTime);
    XWarpPointer(display, None, root, 0, 0, 0, 0, center_x, center_y);
    return 1;
}

void ungrab_input() {
    XUngrabPointer(display, CurrentTime);
    XUngrabKeyboard(display, CurrentTime);
}

int main() {
    display = XOpenDisplay(NULL);
    if (!display) return 1;

    // check XInput 2 availability
    int ev_base, err_base;
    if (!XQueryExtension(display, "XInputExtension", &xi_opcode, &ev_base, &err_base)) {
        fprintf(stderr, "XI2 not supported\n");
        return 1;
    }

    int screen = DefaultScreen(display);
    root = RootWindow(display, screen);
    center_x = DisplayWidth(display, screen) / 2;
    center_y = DisplayHeight(display, screen) / 2;

    win = XCreateSimpleWindow(display, root, 100, 100, WINDOW_SIZE, WINDOW_SIZE, 0, 0, BLUE_PIXEL);
    
    //set event mask
    XSelectInput(display, win, ExposureMask | ButtonPressMask | ButtonReleaseMask | KeyPressMask | KeyReleaseMask);
    
    XStoreName(display, win, "Input Capture Box");
    Atom wm_delete = XInternAtom(display, "WM_DELETE_WINDOW", False);
    XSetWMProtocols(display, win, &wm_delete, 1);

    set_always_on_top(win);
    XMapWindow(display, win);
    blank_cursor = create_blank_cursor();

    XIEventMask mask;
    mask.deviceid = XIAllMasterDevices;
    mask.mask_len = XIMaskLen(XI_RawMotion);
    unsigned char mask_data[XIMaskLen(XI_RawMotion)] = {0};
    XISetMask(mask_data, XI_RawMotion);
    mask.mask = mask_data;
    XISelectEvents(display, root, &mask, 1);

    if (grab_input()) {
        is_capturing = 1;
        fprintf(stderr, "Capture started. (F8 to release)\n");
    }

    XEvent ev;
    while (1) {
        XNextEvent(display, &ev);

        if (ev.type == GenericEvent && ev.xcookie.extension == xi_opcode) {
            if (XGetEventData(display, &ev.xcookie)) {
                if (ev.xcookie.evtype == XI_RawMotion && is_capturing) {
                    XIRawEvent *raw_ev = (XIRawEvent *)ev.xcookie.data;
                    double dx = 0, dy = 0;
                    double *vals = raw_ev->raw_values;
                    if (XIMaskIsSet(raw_ev->valuators.mask, 0)) dx = *vals++;
                    if (XIMaskIsSet(raw_ev->valuators.mask, 1)) dy = *vals;

                    if (dx != 0 || dy != 0) {
                        printf("1 0 %.0f %.0f\n", dx, dy);
                        fflush(stdout);
                        XWarpPointer(display, None, root, 0, 0, 0, 0, center_x, center_y);
                    }
                }
                XFreeEventData(display, &ev.xcookie);
            }
            continue;
        }

        switch (ev.type) {
            case ClientMessage:
                if ((Atom)ev.xclient.data.l[0] == wm_delete) goto cleanup;
                break;

            case KeyPress:
                if (is_capturing) {
                    if (ev.xkey.keycode == EXIT_KEYCODE) {
                        ungrab_input();
                        is_capturing = 0;
                        fprintf(stderr, "Capture released. (Click window to resume)\n");
                    } else {
                        printf("3 %d 0 0\n", ev.xkey.keycode);
                    }
                }
                break;

            case KeyRelease:
                if (is_capturing) printf("3 %d 1 0\n", ev.xkey.keycode);
                break;

            case ButtonPress:
                if (!is_capturing) {
                    if (ev.xbutton.window == win) {
                        if (grab_input()) {
                            is_capturing = 1;
                            fprintf(stderr, "Capture resumed.\n");
                        }
                    }
                } else {
                    if (ev.xbutton.button == 4) printf("2 120 1 0\n");      // Up
                    else if (ev.xbutton.button == 5) printf("2 120 0 0\n"); // Down
                    else printf("0 %d 0 0\n", ev.xbutton.button);
                }
                break;

            case ButtonRelease:
                if (is_capturing && ev.xbutton.button != 4 && ev.xbutton.button != 5) {
                    printf("0 %d 1 0\n", ev.xbutton.button);
                }
                break;
        }
        fflush(stdout);
    }

cleanup:
    XCloseDisplay(display);
    return 0;
}